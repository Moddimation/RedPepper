<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Project RedPepper: Decompilation of Super Mario 3D Land.">
    <link rel="stylesheet" href="https://prp.moddi.dev/assets/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Nunito&disp=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Bungee&disp=swap" rel="stylesheet">
    <link rel="icon" href="https://prp.moddi.dev/assets/favicon.ico" type="image/x-icon">
    <title>File seadPtrArray.h - RedPepper Wiki</title>
  </head>
  <body>
    <div class="container">
      <nav>
        <ul>
        </ul>
      </nav>

      <div id="bar">

          <a id="barTitle" href="https://prp.moddi.dev/"><b>Project RedPepper</b></a>
            <li class="nav-item">
                <button onclick="window.location.href='https://prp.moddi.dev/files/'">
                  Files
                </button>
            </li>
            <li class="nav-item">
                <button onclick="window.location.href='https://prp.moddi.dev/classes/'">
                  Classes
                </button>
            </li>
            <li class="nav-item">
                <button onclick="window.location.href='https://prp.moddi.dev/wiki/'">
                  Full Wiki
                </button>
            </li>
            <li class="nav-item">
                <div class="dropdown">
                  <button class="dropdown-btn"
                          onclick="window.location.href='https://prp.moddi.dev/ver/'">
                    Versions
                  </button>
                  <ul class="dropdown-menu"> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/eu/'">
                          EU
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/eu_d.md'">
                          EU D
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/jp.md'">
                          JP
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/jp_d.md'">
                          JP D
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/us_0.md'">
                          US R0
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/us_1.md'">
                          US R1
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/us_d.md'">
                          US D
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/cn.md'">
                          CN
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/kr.md'">
                          KR
                        </button>
                      </li> 
                      <li>
                        <button onclick="window.location.href='https://prp.moddi.dev/ver/tw.md'">
                          TW
                        </button>
                      </li>
                  </ul>
                </div>
            </li>

      </div>
      
      <h1 id="file-seadptrarrayh">File seadPtrArray.h</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_510f450138bd9d848bdab2e398852591/"><strong>container</strong></a> <strong>&gt;</strong> <a href="../seadPtrArray_8h/"><strong>seadPtrArray.h</strong></a></p>
<p><a href="../seadPtrArray_8h/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">#ifndef SEAD_PTR_ARRAY_H_
#define SEAD_PTR_ARRAY_H_

#include &lt;algorithm&gt;
#include &lt;basis/seadRawPrint.h&gt;
#include &lt;basis/seadTypes.h&gt;
#include &lt;prim/seadMemUtil.h&gt;
#include &lt;random/seadRandom.h&gt;

namespace sead {
class Heap;
class Random;

class PtrArrayImpl {
public:
    PtrArrayImpl() : mPtrNumMax(0), mPtrNum(0), mPtrs(nullptr) {}

    PtrArrayImpl(s32 ptrNumMax, void* buf) : mPtrNumMax(0), mPtrNum(0), mPtrs(nullptr) {
        setBuffer(ptrNumMax, buf);
    }

    void setBuffer(s32 ptrNumMax, void* buf);
    void allocBuffer(s32 ptrNumMax, Heap* heap, s32 alignment = sizeof(void*));
    bool tryAllocBuffer(s32 ptrNumMax, Heap* heap, s32 alignment = sizeof(void*));

    void allocBufferInline(s32 ptrNumMax) {
        mPtrNum = ptrNumMax;
        mPtrs = new void*[ptrNumMax];
    }

    void freeBuffer();

    bool isBufferReady() const { return mPtrs != nullptr; }

    bool isEmpty() const { return mPtrNum == 0; }

    bool isFull() const { return mPtrNum &gt;= mPtrNumMax; }

    s32 size() const { return mPtrNum; }

    s32 capacity() const { return mPtrNumMax; }

    void erase(s32 position) { erase(position, 1); }

    void erase(s32 position, s32 count);

    void clear() { mPtrNum = 0; }

    // TODO
    void resize(s32 size);
    // TODO
    void unsafeResize(s32 size);

    void swap(s32 pos1, s32 pos2) {
        void* ptr = mPtrs[pos1];
        mPtrs[pos1] = mPtrs[pos2];
        mPtrs[pos2] = ptr;
    }

    void reverse();

    void shuffle() {
        Random random;
        shuffle(&amp;random);
    }

    void shuffle(Random* random);

protected:
    typedef int (*CompareCallbackImpl)(const void* a, const void* b);

    void* at(s32 idx) const {
        if (u32(mPtrNumMax) &lt;= u32(idx)) {
            SEAD_ASSERT_MSG(false, &quot;index exceeded [%d/%d]&quot;, idx, mPtrNum);
            return nullptr;
        }
        return mPtrs[idx];
    }

    void* unsafeAt(s32 idx) const { return mPtrs[idx]; }

    // XXX: should this use at()?
    void* front() const { return mPtrs[0]; }

    void* back() const { return mPtrs[mPtrNum - 1]; }

    void pushBack(void* ptr) {
        // Simplest insert case, so this is implemented directly without using insert().
        mPtrs[mPtrNum] = ptr;
        ++mPtrNum;
    }

    void pushFront(void* ptr) { insert(0, ptr); }

    void* popBack() { return isEmpty() ? nullptr : mPtrs[--mPtrNum]; }

    void* popFront() {
        if (isEmpty())
            return nullptr;

        void* result = mPtrs[0];
        erase(0);
        return result;
    }

    void replace(s32 idx, void* ptr) { mPtrs[idx] = ptr; }

    void* find(const void* ptr, CompareCallbackImpl cmp) const {
        for (s32 i = 0; i &lt; mPtrNum; ++i)
            if (cmp(mPtrs[i], ptr) == 0)
                return mPtrs[i];
        return nullptr;
    }

    s32 search(const void* ptr, CompareCallbackImpl cmp) const {
        for (s32 i = 0; i &lt; mPtrNum; ++i)
            if (cmp(mPtrs[i], ptr) == 0)
                return i;
        return -1;
    }

    bool equal(const PtrArrayImpl&amp; other, CompareCallbackImpl cmp) const {
        if (mPtrNum != other.mPtrNum)
            return false;

        for (s32 i = 0; i &lt; mPtrNum; ++i)
            if (cmp(mPtrs[i], other.mPtrs[i]) != 0)
                return false;
        return true;
    }

    s32 indexOf(const void* ptr) const {
        for (s32 i = 0; i &lt; mPtrNum; ++i)
            if (mPtrs[i] == ptr)
                return i;
        return -1;
    }

    void createVacancy(s32 pos, s32 count) {
        if (mPtrNum &lt;= pos)
            return;

        MemUtil::copyOverlap(mPtrs + pos + count, mPtrs + pos,
                             s32(sizeof(void*)) * (mPtrNum - pos));
    }

    void insert(s32 idx, void* ptr);
    void insertArray(s32 idx, void* array, s32 array_length, s32 elem_size);
    bool checkInsert(s32 idx, s32 num);

    void heapSort(CompareCallbackImpl cmp);

    s32 compare(const PtrArrayImpl&amp; other, CompareCallbackImpl cmp) const;
    void uniq(CompareCallbackImpl cmp);

    s32 binarySearch(const void* ptr, CompareCallbackImpl cmp) const {
        if (mPtrNum == 0)
            return -1;

        s32 a = 0;
        s32 b = mPtrNum - 1;
        while (a &lt; b) {
            const s32 m = (a + b) / 2;
            const s32 c = cmp(mPtrs[m], ptr);
            if (c == 0)
                return m;
            if (c &lt; 0)
                a = m + 1;
            else
                b = m;
        }

        if (cmp(mPtrs[a], ptr) == 0)
            return a;

        return -1;
    }

    s32 mPtrNumMax;
    s32 mPtrNum;
    void** mPtrs;
};

template &lt;typename T&gt;
class PtrArray : public PtrArrayImpl {
public:
    PtrArray() {}

    PtrArray(s32 ptrNumMax, T** buf) : PtrArrayImpl(ptrNumMax, buf) {}

    T* at(s32 pos) const { return static_cast&lt;T*&gt;(PtrArrayImpl::at(pos)); }

    T* unsafeAt(s32 pos) const { return static_cast&lt;T*&gt;(PtrArrayImpl::unsafeAt(pos)); }

    T* operator()(s32 pos) const { return unsafeAt(pos); }

    T* operator[](s32 pos) const { return at(pos); }

    // XXX: Does this use at()?
    T* front() const { return at(0); }

    T* back() const { return at(mPtrNum - 1); }

    void pushBack(T* ptr) { PtrArrayImpl::pushBack(ptr); }

    void pushFront(T* ptr) { PtrArrayImpl::pushFront(ptr); }

    T* popBack() { return static_cast&lt;T*&gt;(PtrArrayImpl::popBack()); }

    T* popFront() { return static_cast&lt;T*&gt;(PtrArrayImpl::popFront()); }

    void insert(s32 pos, T* ptr) { PtrArrayImpl::insert(pos, constCast(ptr)); }

    void insert(s32 pos, T* array, s32 count) {
        // XXX: is this right?
        PtrArrayImpl::insertArray(pos, constCast(array), count, sizeof(T));
    }

    void replace(s32 pos, T* ptr) { PtrArrayImpl::replace(pos, constCast(ptr)); }

    s32 indexOf(const T* ptr) const { return PtrArrayImpl::indexOf(ptr); }

    typedef s32 (*CompareCallback)(const T*, const T*);

    bool equal(const PtrArray&amp; other, CompareCallback cmp) const {
        return PtrArrayImpl::equal(other, cmp);
    }

    s32 compare(const PtrArray&amp; other, CompareCallback cmp) const {
        return PtrArrayImpl::compare(other, cmp);
    }

    T* find(const T* ptr, CompareCallback cmp) const { return PtrArrayImpl::find(ptr, cmp); }

    s32 search(const T* ptr, CompareCallback cmp) const { return PtrArrayImpl::search(ptr, cmp); }

    s32 binarySearch(const T* ptr) const { return PtrArrayImpl::binarySearch(ptr, compareT); }

    s32 binarySearch(const T* ptr, CompareCallback cmp) const {
        return PtrArrayImpl::binarySearch(ptr, cmp);
    }

    bool operator==(const PtrArray&amp; other) const { return equal(other, compareT); }

    bool operator!=(const PtrArray&amp; other) const { return !(*this == other); }

    void uniq() { PtrArrayImpl::uniq(compareT); }

    void uniq(CompareCallback cmp) { PtrArrayImpl::uniq(cmp); }

    class iterator {
    public:
        iterator(T* const* pptr) : mPPtr(pptr) {}

        bool operator==(const iterator&amp; other) const { return mPPtr == other.mPPtr; }

        bool operator!=(const iterator&amp; other) const { return !(*this == other); }

        iterator&amp; operator++() {
            ++mPPtr;
            return *this;
        }

        T&amp; operator*() const { return **mPPtr; }

        T* operator-&gt;() const { return *mPPtr; }

    private:
        T* const* mPPtr;
    };

    iterator begin() const { return iterator(data()); }

    iterator end() const { return iterator(data() + mPtrNum); }

    class constIterator {
    public:
        constIterator(const T* const* pptr) : mPPtr(pptr) {}

        bool operator==(const constIterator&amp; other) const { return mPPtr == other.mPPtr; }

        bool operator!=(const constIterator&amp; other) const { return !(*this == other); }

        constIterator&amp; operator++() {
            ++mPPtr;
            return *this;
        }

        const T&amp; operator*() const { return **mPPtr; }

        const T* operator-&gt;() const { return *mPPtr; }

    private:
        const T* const* mPPtr;
    };

    constIterator constBegin() const { return constIterator(data()); }

    constIterator constEnd() const { return constIterator(data() + mPtrNum); }

    T** data() const { return reinterpret_cast&lt;T**&gt;(mPtrs); }

    T** dataBegin() const { return data(); }

    T** dataEnd() const { return data() + mPtrNum; }

protected:
    static int compareT(const void* a_, const void* b_) {
        const T* a = static_cast&lt;const T*&gt;(a_);
        const T* b = static_cast&lt;const T*&gt;(b_);
        if (*a &lt; *b)
            return -1;
        if (*b &lt; *a)
            return 1;
        return 0;
    }
};

template &lt;typename T, s32 N&gt;
class FixedPtrArray : public PtrArray&lt;T&gt; {
public:
    FixedPtrArray() : PtrArray&lt;T&gt;(N, mWork) {}

private:
    // Nintendo uses an untyped u8[N*sizeof(void*)] buffer. That is undefined behavior,
    // so we will not do that.
    T* mWork[N];
};

}  // namespace sead

#endif  // SEAD_PTR_ARRAY_H_
</code></pre>
        <script src="../../search/main.js"></script>
    </div>
  </body>
</html>